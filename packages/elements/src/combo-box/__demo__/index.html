<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <title>Combo Box</title>
    <script src="countries.js"></script>
  </head>
  <body>
    <script type="module">
      import '@refinitiv-ui/elements/combo-box';

      import '@refinitiv-ui/demo-block';
      import '@refinitiv-ui/demo-block/demo.css';

      // Dynamic import theme files from search params of the URL
      // Ex. http://localhost:3000?theme=halo&varint=dark will load halo-theme/dark
      const url = new URL(window.location);
      const theme = url.searchParams.get('theme') || 'halo';
      const variant = url.searchParams.get('variant') || 'light';

      if (!window.location.search) {
        url.searchParams.set('theme', theme);
        url.searchParams.append('variant', variant);
        window.location.search = url.searchParams.toString();
      }

      import(`../../../../../node_modules/@refinitiv-ui/${theme}-theme/${variant}/css/native-elements.css`);
      import(`../../../lib/combo-box/themes/${theme}/${variant}/index.js`);
    </script>
    <script type="module">
      // Translations
      import '@refinitiv-ui/phrasebook/locale/de/combo-box.js';
      import '@refinitiv-ui/phrasebook/locale/ja/combo-box.js';
      import '@refinitiv-ui/phrasebook/locale/zh-hant/combo-box.js';
      import '@refinitiv-ui/phrasebook/locale/zh/combo-box.js';
    </script>
    <script type="module">
      const makeData = (config = {}) => {
        if (config.selectionTooltip) {
          return Array(1001)
            .fill(0)
            .map((_, i) => ({
              type: 'text',
              label: `Item number ${i + 1}`,
              value: (i + 1).toString(),
              selected: true
            }));
        } else {
          return window.countries.reduce((countries, _, i) => {
            const lastItem = countries[countries.length - 1];
            if (!lastItem || lastItem.label[0] !== _.label[0]) {
              countries.push({
                type: 'header',
                label: `${_.label[0]}`
              });
            }
            countries.push({
              type: 'text',
              label: _.label,
              value: _.value,
              selected:
                config.selected || config.selected === undefined
                  ? i === 109 || (config.multiple && i === 1)
                  : false,
              disabled: config.disabled === undefined ? i % 10 === 7 : false,
              hidden: config.hidden === undefined ? i % 50 === 49 : false
            });
            return countries;
          }, []);
        }
      };
      window.makeData = makeData;

      document.querySelectorAll('ef-combo-box').forEach((el) => {
        switch (el.id) {
          case 'empty':
          case 'load':
          case 'asynchronous':
          case 'lang-no-options':
            // do nothing
            break;
          case 'placeholder':
            el.data = makeData({ selected: false });
            break;
          case 'translationsComboBox':
          case 'multiple':
            el.data = makeData({ multiple: true });
            break;
          case 'selection-tooltip':
            el.data = makeData({ selectionTooltip: true });
            break;

          default:
            el.data = makeData();
            break;
        }
      });
    </script>
    <demo-block header="Default" layout="normal" tags="default">
      <p>
        <ef-combo-box id="default"></ef-combo-box>
      </p>
      <p>
        <ef-combo-box id="placeholder" value="gb"></ef-combo-box>
      </p>
    </demo-block>

    <demo-block header="Multiple" layout="normal" tags="multiple selection">
      <p>
        <ef-combo-box id="multiple" multiple></ef-combo-box>
      </p>
      <p>
        <ef-combo-box id="selection-tooltip" multiple></ef-combo-box>
      </p>
    </demo-block>

    <demo-block header="Empty" layout="normal" tags="empty">
      <ef-combo-box id="empty"></ef-combo-box>
    </demo-block>

    <demo-block header="Free Text" layout="normal" tags="free text">
      <ef-combo-box id="free-text" free-text></ef-combo-box>
    </demo-block>

    <demo-block header="Loading static data" layout="normal" tags="empty">
      <ef-combo-box id="load"></ef-combo-box>
      <div>
        <button id="load-data">Load Data</button>
        <button id="trigger-opened">Set Opened</button>
      </div>
      <script>
        const loadDataCombo = document.getElementById('load');
        const loadButton = document.getElementById('load-data');
        const triggerOpened = document.getElementById('trigger-opened');
        loadButton.addEventListener('click', () => {
          loadDataCombo.data = makeData();
        });
        triggerOpened.addEventListener('click', () => {
          loadDataCombo.opened = !loadDataCombo.opened;
        });
      </script>
    </demo-block>

    <demo-block header="Filter" layout="normal" tags="filters">
      <ef-combo-box id="filter"></ef-combo-box>
    </demo-block>

    <demo-block header="Custom Filter" layout="normal" tags="filters, custom">
      <ef-combo-box id="custom-filter"></ef-combo-box>
      <script>
        const customFilterCombo = document.getElementById('custom-filter');
        const customFilter = (comboBox) => {
          // reference query string for validating queryRegExp cache state
          let query = '';
          // cache RegExp
          let queryRegExp;

          // Get current RegExp, or renew if out of date
          // this is fetched on demand by filter/renderer
          // only created once per query
          const getRegularExpressionOfQuery = () => {
            if (comboBox.query !== query || !queryRegExp) {
              query = comboBox.query || '';
              queryRegExp = new RegExp(query.replace(/(\W)/g, '\\$1'), 'i');
            }
            return queryRegExp;
          };

          // return scoped custom filter
          return (item) => {
            const regex = getRegularExpressionOfQuery();
            // test on label or value
            const result = query === item.value || regex.test(item.label);
            regex.lastIndex = 0; // do not forget to reset last index
            return result;
          };
        };

        customFilterCombo.filter = customFilter(customFilterCombo);
      </script>
    </demo-block>

    <demo-block header="Query debouncer" layout="normal" tags="queryDebounceRate">
      <input type="text" placeholder="Query debounce rate" id="debounce-val" />
      <ef-combo-box id="debounce"></ef-combo-box>
      <script>
        const debounceInput = document.getElementById('debounce-val');
        const debouncer = document.getElementById('debounce');
        debounceInput.addEventListener('input', () => {
          debouncer.queryDebounceRate = debounceInput.value;
        });
      </script>
    </demo-block>

    <demo-block header="Placeholder" layout="normal" tags="placeholder">
      <ef-combo-box id="placeholder" placeholder="Select..."></ef-combo-box>
    </demo-block>

    <demo-block header="Clearable + Placeholder" layout="normal" tags="clears, placeholder">
      <ef-combo-box clears id="clears" placeholder="Select..."></ef-combo-box>
    </demo-block>

    <demo-block header="Custom renderer" layout="normal" tags="renderer">
      <ef-combo-box id="custom-renderer"></ef-combo-box>
      <script type="module">
        import { createComboBoxRenderer } from '@refinitiv-ui/elements/combo-box';
        import '@refinitiv-ui/elements/flag';

        const createFlagRender = (context) => {
          // Keep the reference to the default renderer
          const renderer = createComboBoxRenderer(context);
          // store reference to flag for easy access.
          // Use WeakMap to not care about memory leaks
          const flagMap = new WeakMap();

          // Return the closure
          return (item, composer, element) => {
            element = renderer(item, composer, element);
            const type = composer.getItemPropertyValue(item, 'type');
            // reuse existing flag element if available
            let flagElement = flagMap.get(element);
            if (!flagElement && (!type || type === 'text')) {
              // Text items
              flagElement = document.createElement('ef-flag');
              flagElement.slot = 'left';
              element.appendChild(flagElement);
              flagMap.set(element, flagElement);
            } else if (flagElement && type && type !== 'text') {
              // Header items, which should not have a flag
              // Make sure that flag element is removed
              flagElement.parentNode.removeChild(flagElement);
              flagMap.remove(element, flagElement);
              flagElement = null;
            }

            // Make sure that you can re-use the same element with new data item
            if (flagElement) {
              flagElement.flag = composer.getItemPropertyValue(item, 'value');
            }

            return element;
          };
        };

        const customRenderer = document.getElementById('custom-renderer');
        customRenderer.renderer = createFlagRender(customRenderer);
      </script>
    </demo-block>

    <demo-block header="States" layout="normal" tags="disabled,readonly,error">
      <div>Disabled</div>
      <ef-combo-box disabled></ef-combo-box>
      <div>Readonly</div>
      <ef-combo-box readonly></ef-combo-box>
      <div>Warning</div>
      <ef-combo-box warning></ef-combo-box>
      <div>Error</div>
      <ef-combo-box error></ef-combo-box>
    </demo-block>
    <demo-block header="Translations" tags="translations,i18n" layout="normal">
      <ef-combo-box id="translationsComboBox" multiple></ef-combo-box>
      <ef-combo-box id="lang-no-options"></ef-combo-box>
      <div>
        <button onclick="openTranslateComboBox('')">Default</button>
        <button onclick="openTranslateComboBox('de')">de</button>
        <button onclick="openTranslateComboBox('en')">en</button>
        <button onclick="openTranslateComboBox('ja')">ja</button>
        <button onclick="openTranslateComboBox('zh')">zh</button>
        <button onclick="openTranslateComboBox('zh-Hant')">zh-hant</button>
      </div>
      <script>
        const translationsComboBoxList = [
          document.getElementById('translationsComboBox'),
          document.getElementById('lang-no-options')
        ];
        window.openTranslateComboBox = function (lang) {
          translationsComboBoxList.forEach((combo) => {
            combo.lang = lang;
          });
        };
      </script>
      <style>
        #translationsComboBox {
          min-width: 160px;
        }
      </style>
    </demo-block>

    <demo-block header="Asynchronous filter" layout="normal" tags="async, filter">
      <ef-combo-box id="asynchronous" query-debounce-rate="200" value="gb"></ef-combo-box>
      <script type="module">
        (function () {
          const data = window.makeData({ selected: false, hidden: false, disabled: false });
          const comboBox = document.getElementById('asynchronous');
          comboBox.filter = null;

          // Function to make request. In real life scenario it may wrap fetch
          const request = (query, value) => {
            const regex = new RegExp(query.replace(/(\W)/g, '\\$1'), 'i');

            // Always keep a promise the let Combo Box know that the data is loading
            return new Promise((resolve) => {
              const filterData = [];
              if (query || value) {
                for (let i = 0; i < data.length; i += 1) {
                  const item = data[i];
                  // Include element itself
                  // Mark value hidden if it does not match search query
                  if (value && item.value === value) {
                    filterData.push(
                      Object.assign({}, item, {
                        selected: true,
                        hidden: query ? !regex.test(item.label) : false
                      })
                    );
                    regex.lastIndex = 0;
                    continue;
                  }

                  if (query && regex.test(item.label)) {
                    filterData.push(item);
                    regex.lastIndex = 0;
                  }
                }
              }
              setTimeout(() => {
                resolve(filterData);
              }, 500);
            });
          };

          // Populate self with the initial value
          comboBox.data = request('', 'gb');

          // Listen for query change event
          comboBox.addEventListener('query-changed', (event) => {
            comboBox.data = request(comboBox.query, comboBox.value);
          });
        })();
      </script>
    </demo-block>
  </body>
</html>
